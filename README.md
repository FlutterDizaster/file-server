# file-server
В этом репозитории содержися исполнение тестового задания на позицию Entry Middle разработчика.

## Что было реализовано
- [x] Регистрация пользователя
- [x] Аутентификация пользователя
- [x] Загрузка нового документа
- [x] Получение списка документов
- [x] Получение одного документа
- [x] Удаление документа
- [x] Кеширование в Redis

## Основные компоненты приложения
- file-service - этот проект
- Redis - хранение кеша пользователя
- PostgreSQL - хранение метаданных документов и данных пользователей
- Minio - хранение бинарных данных

## Краткое описание работы сервиса
### Регистрация и Аутентификация
При регистрации клиент передает запрос содержащий токен администратора, логин и пароль.
Сначала проверяется валидность токена администратора, затем соответствие логина и пароля указанным требованиям.
Если всё хорошо, создается bcrypt hash пароля и данные добавляются в базу.

При аутентификации клиент передает запрос с логином и паролем, после чего по логину пользователя данные получаются из бд и пароль сравнивается с хешем используя библиотеку bcrypt

В обоих случаях генерируется и возвращается jwt токен для использования в других запросах.

### Работа с документами
#### Загрузка нового документа
При загрузке документа инвалидируется кеш пользователя, метаданные документа добавляются в базу данных а файл загружается в Minio object storage по мере поступления данных от клиента. Т.е. файл никогда не находится в памяти полностью. 
Кстати тут можно было бы ещё применить другой подход. Мы можем сделать так, чтобы Minio сам отправлял метаданные в бд после успешной загрузки файла.

#### Получение списка документов
При получении списка документов сначала происходит попытка получения всех метаданных документов пользователя из кеша, если их там нет, то данные получаются из бд и добавляются в кеш. 
После идет парсинг параметров фильтрации и сама фильтрация с последующим возвращением данных клиенту. 
Список фильтров и их параметров описан в пакете filters.

#### Получение одного документа
При получении запроса на загрузку документа, приложение обращается к кешу и при необходимости в бд для получения метаданных документа и начинается проверка доступа (так же через фильтрацию как при получении списка всех документов, только limit установлен 1 и в качестве фильтров используется фильтр доступа). Если файл доступен пользователю, то происходит запрос в Minio для получения файла. Файл отдается используя http.ServeContent для поддержки Range запросову и использования буферизированной записи, чтобы не загружать файл из Minio полностью перед отдачей его клиенту. Если файл, это JSON объект, то он просто отдается из базы данных, так как хранится вместе с метаданными.

#### Удаление документа
При получении запроса на удаление документа, происходит проверка на то имеет ли пользователь на это право и в случае успеха очищается кеш пользователя, метададанные в бд помечаются как удаленные, чтобы не пересчитывать индексы, а сам файл просто удаляется из object storage.

### Кеш
Кеш реализован в Redis. Модель работы кеша предпологает удаление кеша пользователя при получении запросов изменяющих состояние и полное обновление кеша при запросах на получние данных, если они не были сохранены раньше.
Так же есть ещё варианты с обновлением кеша и его версионированием. У всех вариантов есть свои плюсы и минусы, но мной был выбран вариант указанный в тз. 

### Фильтрация
Фильтрация данных на стороне приложения была выбрана для упрощения логики работы с бд и кешем. Можно было бы использовать механизм для билдинга запроса по фильтрам, но это заняло бы кратно больше времени на имплементацию.
Реализовано всё через структуру DocumentsFilter. Сначала создается экземпляр указанной структуры с указанием limit и offset (последнего не было в тз, но я решил его добавить. По умолчанию он будет равен 0, так что не страшно, если он не будет передан). После чего можно добавить фильтры через соответсвующую функцию. Она содержит логику выбора подходящего фильтра по ключу и добавления его в список фильтров. Подробнее можно увидеть в коде, там всё достаточно понятно реализовано. 
Функция фильтрации

## Используемые внешние библиотеки
- github.com/golang-jwt/jwt/v4 - для генерации jwt токенов.
- github.com/google/uuid - для работы с UUID.
- github.com/spf13/pflag - зависимость пакета configloader. Позволяет очень гибко парсить флаги.
- github.com/stretchr/testify - используется в тестах.
- github.com/minio/minio-go/v7 - sdk для работы с S3 compatable object storage.
- github.com/redis/go-redis/v9 - sdk redis. Используется для кеширования.
- github.com/golang-migrate/migrate/v4 - необходим для запуска миграций.
- github.com/jackc/pgx - библиотека для работы с PostgreSQL.
- github.com/mailru/easyjson - Используется для генерации функций для маршалинга и анмаршалинга объектов без использования рефлексии.

## Возмодные улучшения
- Добавить docker-compose для запуска запуска приложения вместе с зависимостями.
- Добавить в пакет configloader функционал определения типа конфиг файла и анмаршалинг его нужным декодером.
- Покрыть код тестами. Я написал несколько тестов, но для production кода этого, конечно, маловато. 
- Добавить бенчмарки к потенциально затратным по расходу ресурсов функциям.
- Добавить возможность сборки dev билда без оптимизаций линтера и доп функционалом например ендпоинтов для профилирования.
- Стоит так же добавить сбор метрик через prometheus. Это позволит выделить узкие места приложения и оптимизировать TTL кеша.
- Можно ещё добавить трейсинг через Sentry для более удобного отследивания ошибок.
- На самом деле многое можно сделать лучше. Я относился к тестовому заданию как к некому proof of concept приложению, так что ещё есть над чем поработать.